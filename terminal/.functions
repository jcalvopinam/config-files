#!/usr/bin/env bash
# Functions

#----------------------------------------------------------------------------------
# Uses Git’s colored diff when available
hash git &>/dev/null;
#----------------------------------------------------------------------------------
if [ $? -eq 0 ]; then
    function diff() {
        git diff --no-index --color-words "$@";
    }
fi;


#----------------------------------------------------------------------------------
# Shows git prompt
#----------------------------------------------------------------------------------
function gprompt() {
    local s='';
    local branchName='';

    # Checks if the current directory is in a Git repository.
    if [ $(git rev-parse --is-inside-work-tree &>/dev/null; echo "${?}") == '0' ]; then

        # checks if the current directory is in .git before running git checks
        if [ "$(git rev-parse --is-inside-git-dir 2> /dev/null)" == 'false' ]; then

            # Ensures the index is up to date.
            git update-index --really-refresh -q &>/dev/null;

            # Checks for uncommitted changes in the index.
            if ! $(git diff --quiet --ignore-submodules --cached); then
                s+='+';
            fi;

            # Checks for unstaged changes.
            if ! $(git diff-files --quiet --ignore-submodules --); then
                s+='!';
            fi;

            # Checks for untracked files.
            if [ -n "$(git ls-files --others --exclude-standard)" ]; then
                s+='?';
            fi;

            # Checks for stashed files.
            if $(git rev-parse --verify refs/stash &>/dev/null); then
                s+='$';
            fi;

        fi;

        # Gets the short symbolic ref.
        # If HEAD isn’t a symbolic ref, get the short SHA for the latest commit
        # Otherwise, just give up.
        branchName="$(git symbolic-ref --quiet --short HEAD 2> /dev/null || \
            git rev-parse --short HEAD 2> /dev/null || \
            echo '(unknown)')";

        [ -n "${s}" ] && s=" [${s}]";

        # PS1 defaulf
        # echo -e "${1}${branchName}${2}${s}";
        # PS1 custom git
        echo -e "${1}(${branchName}${s}) ${2}";
    else
        return;
    fi;
}


#----------------------------------------------------------------------------------
# Shows git tree
#----------------------------------------------------------------------------------
function gtree() {
    tree -aC -I '.git|node_modules|bower_components' --dirsfirst "$@" | less -FRNX;
}


#----------------------------------------------------------------------------------
# Gets the name of the parent branch
#----------------------------------------------------------------------------------
function gparent() {
    git show-branch -a \
    | grep '\*' \
    | grep -v `git rev-parse --abbrev-ref HEAD` \
    | head -n1 \
    | sed 's/.*\[\(.*\)\].*/\1/' \
    | sed 's/[\^~].*//'
}


#----------------------------------------------------------------------------------
# Shows git diff
#----------------------------------------------------------------------------------
function gdiff() {
  git diff $@ --name-only | fzf --no-height --pointer='->' --header="`date`" \
  -e --no-sort --reverse -m --ansi --preview-window="right:70%,wrap" \
  --preview "git diff $@  --abbrev --color=always  -- {-1}"
}


#----------------------------------------------------------------------------------
# Shows git log
#----------------------------------------------------------------------------------
function glogg() {
  git log $@ --abbrev --oneline --decorate --color \
  --pretty=format:"%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset" \
  --abbrev-commit | fzf --no-height --pointer='->' --header="`date`" -e --no-sort \
  --reverse -m --ansi --preview-window="right:70%,wrap" \
  --preview "git show {1} --color=always --abbrev --show-signature " | awk -F' ' {'print $1'}
}


#----------------------------------------------------------------------------------
# Shows git branches
#----------------------------------------------------------------------------------
function gbranch() {
    selected=( $(git branch | grep -v '/HEAD\s' | grep -v "*" | awk -F' ' {'print $1'} | \
    fzf --pointer='->' --header="`date`" --height 30% --inline-info \
        --layout reverse --border --no-sort --reverse -m --ansi))
    echo $selected | pbcopy
}


#----------------------------------------------------------------------------------
# Shows git branches and switch it
#----------------------------------------------------------------------------------
function gswitch() {
  git switch $(git branch | grep -v '/HEAD\s' | grep -v "*" | awk -F' ' {'print $1'} | \
    fzf --pointer='->' --header="`date`" --height 30% --inline-info --layout reverse \
    --border --no-sort --reverse -m --ansi)
}

#----------------------------------------------------------------------------------
# Shows git status
#----------------------------------------------------------------------------------
function gstatus() {
  git status -s | awk '{print $2 " " $1}'| fzf --no-sort --reverse \
  --preview 'git diff --color=always {+1}' --bind=ctrl-j:preview-down \
  --bind=ctrl-k:preview-up --preview-window=right:60%:wrap
}


#----------------------------------------------------------------------------------
# Creates a new folder and enter it
#----------------------------------------------------------------------------------
function mkd() {
    mkdir -p "$@" && cd "$_";
}


#----------------------------------------------------------------------------------
# Deletes file/folder with scrub utility
#----------------------------------------------------------------------------------
function rmk() {
    scrub -p dod $1
    shred -zun 10 -v $1
}


#----------------------------------------------------------------------------------
# Gets the size of a file or total size of a directory
#----------------------------------------------------------------------------------
function file-size() {
    if du -b /dev/null > /dev/null 2>&1; then
        local arg=-sbh;
    else
        local arg=-sh;
    fi
    if [[ -n "$@" ]]; then
        du $arg -- "$@";
    else
        du $arg .[^.]* ./*;
    fi;
}


#----------------------------------------------------------------------------------
# Gets the most useful info
#----------------------------------------------------------------------------------
function digga() {
    dig +nocmd "$1" any +multiline +noall +answer;
}


#----------------------------------------------------------------------------------
# UTF-8-encode a string of Unicode symbols
#----------------------------------------------------------------------------------
function utf8() {
    printf "\\\x%s" $(printf "$@" | xxd -p -c1 -u);
    # print a newline unless we’re piping the output to another program
    if [ -t 1 ]; then
        echo ""; # newline
    fi;
}


#----------------------------------------------------------------------------------
# Extract and open project with IntelliJ, currently this only supports "zip" files.
#                    The command uio means Unzip Intellij Open
# Keep in mind that the "idea" command must be enabled, if you aren't sure, please
# open IntelliJ and go to "Tools > Create Command-line Launcher..." and hit "OK"
# sample how to use: uio project-name.zip
# > uio demo.zip
#----------------------------------------------------------------------------------
function uio() {
    project=$1
    filename=$(basename -- "$project")
    extension="${filename##*.}"
    filename="${filename%.*}"

    if [ "$project" = "" ]; then
        echo " ::Please enter the file name..."
    else
        if [[ ${extension} == "zip" ]]; then
            unzip -q $project
            echo " ::Checking the project structure ..."
            cd $filename
            if [ -e pom.xml ] || [ -e build.gradle ]; then
                echo " ::Opening the project" $filename
                cd ..
                idea $filename & 
                sleep 5
                echo " "
            else
                cd ..
                rm -rf $filename
                echo " ::The structure of the project is not maven nor gradle"
            fi
        else
            echo " :: Extension file doesn't support...."
        fi
    fi
}


#----------------------------------------------------------------------------------
# Set 'man' colors
#----------------------------------------------------------------------------------
function man() {
    env \
    LESS_TERMCAP_mb=$'\e[01;31m' \
    LESS_TERMCAP_md=$'\e[01;31m' \
    LESS_TERMCAP_me=$'\e[0m' \
    LESS_TERMCAP_se=$'\e[0m' \
    LESS_TERMCAP_so=$'\e[01;44;33m' \
    LESS_TERMCAP_ue=$'\e[0m' \
    LESS_TERMCAP_us=$'\e[01;32m' \
    man "$@"
}


#----------------------------------------------------------------------------------
# Finds files inside of the current path
#----------------------------------------------------------------------------------
function ff() {
    selected=( $(if [ "$1" = "h" ]; then
        fzf -m --reverse --preview-window down:20 --preview '[[ $(file --mime {}) =~ binary ]] &&
                    echo {} is a binary file ||
                     (bat --style=numbers --color=always {} ||
                      highlight -O ansi -l {} ||
                      coderay {} ||
                      rougify {} ||
                      cat {}) 2> /dev/null | head -500'

    else
            fzf -m --preview '[[ $(file --mime {}) =~ binary ]] &&
                             echo {} is a binary file ||
                             (bat --style=numbers --color=always {} ||
                              highlight -O ansi -l {} ||
                              coderay {} ||
                              rougify {} ||
                              cat {}) 2> /dev/null | head -500'
    fi))

    nvim $selected
}


#----------------------------------------------------------------------------------
# Finds folders inside of the current path
#----------------------------------------------------------------------------------
function fd() {
    local cmd="${FZF_ALT_C_COMMAND:-"command find -L . -mindepth 1 \\( -path '*/\\.*' -o -fstype 'sysfs' -o -fstype 'devfs' -o -fstype 'devtmpfs' -o -fstype 'proc' \\) -prune \
    -o -type d -print 2> /dev/null | cut -b3-"}"

    local dir="$(eval "$cmd" | FZF_DEFAULT_OPTS="--height ${FZF_TMUX_HEIGHT:-40%} --reverse --bind=ctrl-z:ignore ${FZF_DEFAULT_OPTS-} ${FZF_ALT_C_OPTS-}" $(__fzfcmd) +m)"

    if [[ -z "$dir" ]]; then
        return 0
    fi

    cd -- ${(q)dir}
}

#----------------------------------------------------------------------------------
# Clean duplicated entries
#----------------------------------------------------------------------------------
function czsh() {
    cd ~
    cat -n .zsh_history | sort -t ';' -uk2 | sort -nk1 | cut -f2- > .zsh_clean_history
    rm -rf .zsh_history .zcompdump* .zsh_sessions
    mv .zsh_clean_history .zsh_history
    cd -
}
