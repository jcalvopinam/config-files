#!/usr/bin/env bash
# Functions

#----------------------------------------------------------------------------------
# Some functions were adapted from: https://github.com/junegunn/fzf-git.sh
# MIT License
#----------------------------------------------------------------------------------
if [[ $# -eq 1 ]]; then
  branches() {
    git branch "$@" --sort=-committerdate --sort=-HEAD --format=$'%(HEAD) %(color:yellow)%(refname:short) %(color:green)(%(committerdate:relative))\t%(color:blue)%(subject)%(color:reset)' --color=always | column -ts$'\t'
  }
  refs() {
    git for-each-ref --sort=-creatordate --sort=-HEAD --color=always --format=$'%(refname) %(color:green)(%(creatordate:relative))\t%(color:blue)%(subject)%(color:reset)' |
      eval "$1" |
      sed 's#^refs/remotes/#\x1b[95mremote-branch\t\x1b[33m#; s#^refs/heads/#\x1b[92mbranch\t\x1b[33m#; s#^refs/tags/#\x1b[96mtag\t\x1b[33m#; s#refs/stash#\x1b[91mstash\t\x1b[33mrefs/stash#' |
      column -ts$'\t'
  }
  case "$1" in
    branches)
      echo $'ESC (exit) ╱ ALT-A (show all branches)\n'
      branches
      ;;
    all-branches)
      echo $'ESC (exit)\n'
      branches -a
      ;;
    refs)
      echo $'ESC (exit) ╱ ALT-E (examine in editor) ╱ ALT-A (show all refs)\n'
      refs 'grep -v ^refs/remotes'
      ;;
    all-refs)
      echo $'ESC (exit) ╱ ALT-E (examine in editor)\n'
      refs 'cat'
      ;;
    nobeep) ;;
    *) exit 1 ;;
  esac
elif [[ $# -gt 1 ]]; then
  set -e

  branch=$(git rev-parse --abbrev-ref HEAD 2> /dev/null)
  if [[ $branch = HEAD ]]; then
    branch=$(git describe --exact-match --tags 2> /dev/null || git rev-parse --short HEAD)
  fi

  exit 0
fi

__fzf_git=${BASH_SOURCE[0]:-${(%):-%x}}
__fzf_git=$(readlink -f "$__fzf_git" 2> /dev/null || /usr/bin/ruby --disable-gems -e 'puts File.expand_path(ARGV.first)' "$__fzf_git" 2> /dev/null)


#----------------------------------------------------------------------------------
# Internal functions
#----------------------------------------------------------------------------------
_git_fzf() {
  fzf-tmux -p80%,60% -- \
    --layout=reverse --multi --height=50% --min-height=20 --border \
    --color='header:italic:underline' \
    --preview-window='right,50%,border-left' \
    --bind='ctrl-/:change-preview-window(down,50%,border-top|hidden|)' "$@"
}

_git_check() {
  git rev-parse HEAD > /dev/null 2>&1 && return

  [[ -n $TMUX ]] && tmux display-message "Not in a git repository"
  return 1
}


#----------------------------------------------------------------------------------
# Shows git prompt
#----------------------------------------------------------------------------------
function gprompt() {
    local s='';
    local branchName='';

    # Checks if the current directory is in a Git repository.
    if [ $(git rev-parse --is-inside-work-tree &>/dev/null; echo "${?}") == '0' ]; then

        # checks if the current directory is in .git before running git checks
        if [ "$(git rev-parse --is-inside-git-dir 2> /dev/null)" == 'false' ]; then

            # Ensures the index is up to date.
            git update-index --really-refresh -q &>/dev/null;

            # Checks for uncommitted changes in the index.
            if ! $(git diff --quiet --ignore-submodules --cached); then
                s+='+';
            fi;

            # Checks for unstaged changes.
            if ! $(git diff-files --quiet --ignore-submodules --); then
                s+='!';
            fi;

            # Checks for untracked files.
            if [ -n "$(git ls-files --others --exclude-standard)" ]; then
                s+='?';
            fi;

            # Checks for stashed files.
            if $(git rev-parse --verify refs/stash &>/dev/null); then
                s+='$';
            fi;

        fi;

        # Gets the short symbolic ref.
        # If HEAD isn’t a symbolic ref, get the short SHA for the latest commit
        # Otherwise, just give up.
        branchName="$(git symbolic-ref --quiet --short HEAD 2> /dev/null || \
            git rev-parse --short HEAD 2> /dev/null || \
            echo '(unknown)')";

        [ -n "${s}" ] && s=" [${s}]";

        # PS1 defaulf
        # echo -e "${1}${branchName}${2}${s}";
        # PS1 custom git
        echo -e "${1}(${branchName}${s}) ${2}";
    else
        return;
    fi;
}


#----------------------------------------------------------------------------------
# Shows git tree
#----------------------------------------------------------------------------------
function gtree() {
    tree -aC -I '.git|node_modules|bower_components' --dirsfirst "$@" | less -FRNX;
}


#----------------------------------------------------------------------------------
# Gets the name of the parent branch
#----------------------------------------------------------------------------------
function gparent() {
    git show-branch -a \
    | grep '\*' \
    | grep -v `git rev-parse --abbrev-ref HEAD` \
    | head -n1 \
    | sed 's/.*\[\(.*\)\].*/\1/' \
    | sed 's/[\^~].*//'
}


#----------------------------------------------------------------------------------
# Shows git diff
#----------------------------------------------------------------------------------
function gdiff() {
  git diff $@ --name-only | fzf --no-height --pointer='->' --header="`date`" \
  -e --no-sort --reverse -m --ansi --preview-window="right:70%,wrap" \
  --preview "git diff $@  --abbrev --color=always  -- {-1}"
}


#----------------------------------------------------------------------------------
# Shows git log
#----------------------------------------------------------------------------------
function glogg() {
  git log $@ --abbrev --oneline --decorate --color \
  --pretty=format:"%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset" \
  --abbrev-commit | fzf --no-height --pointer='->' --header="`date`" -e --no-sort \
  --reverse -m --ansi --preview-window="right:70%,wrap" \
  --preview "git show {1} --color=always --abbrev --show-signature " | awk -F' ' {'print $1'}
}


#----------------------------------------------------------------------------------
# Shows git branches
#----------------------------------------------------------------------------------
function gbranch() {
    selected=( $(git branch | grep -v '/HEAD\s' | grep -v "*" | awk -F' ' {'print $1'} | \
    fzf --pointer='->' --header="`date`" --height 30% --inline-info \
        --layout reverse --border --no-sort --reverse -m --ansi))
    echo $selected | pbcopy
}


#----------------------------------------------------------------------------------
# Shows git branches and switch it
#----------------------------------------------------------------------------------
function gswitch() {
  git switch $(git branch | grep -v '/HEAD\s' | grep -v "*" | awk -F' ' {'print $1'} | \
    fzf --pointer='->' --header="`date`" --height 30% --inline-info --layout reverse \
    --border --no-sort --reverse -m --ansi)
}

#----------------------------------------------------------------------------------
# Shows git status
#----------------------------------------------------------------------------------
function gstatus() {
  git status -s | awk '{print $2 " " $1}'| fzf --no-sort --reverse \
  --preview 'git diff --color=always {+1}' --bind=ctrl-j:preview-down \
  --bind=ctrl-k:preview-up --preview-window=right:60%:wrap
}


#----------------------------------------------------------------------------------
# Creates a new folder and enter it
#----------------------------------------------------------------------------------
function mkd() {
    mkdir -p "$@" && cd "$_";
}


#----------------------------------------------------------------------------------
# Deletes file/folder with scrub utility
#----------------------------------------------------------------------------------
function rmk() {
    scrub -p dod $1
    shred -zun 10 -v $1
}


#----------------------------------------------------------------------------------
# Gets the size of a file or total size of a directory
#----------------------------------------------------------------------------------
function file-size() {
    if du -b /dev/null > /dev/null 2>&1; then
        local arg=-sbh;
    else
        local arg=-sh;
    fi
    if [[ -n "$@" ]]; then
        du $arg -- "$@";
    else
        du $arg .[^.]* ./*;
    fi;
}


#----------------------------------------------------------------------------------
# Gets the most useful info
#----------------------------------------------------------------------------------
function digga() {
    dig +nocmd "$1" any +multiline +noall +answer;
}


#----------------------------------------------------------------------------------
# UTF-8-encode a string of Unicode symbols
#----------------------------------------------------------------------------------
function utf8() {
    printf "\\\x%s" $(printf "$@" | xxd -p -c1 -u);
    # print a newline unless we’re piping the output to another program
    if [ -t 1 ]; then
        echo ""; # newline
    fi;
}


#----------------------------------------------------------------------------------
# Extract and open project with IntelliJ, currently this only supports "zip" files.
#                    The command uio means Unzip Intellij Open
# Keep in mind that the "idea" command must be enabled, if you aren't sure, please
# open IntelliJ and go to "Tools > Create Command-line Launcher..." and hit "OK"
# sample how to use: uio project-name.zip
# > uio demo.zip
#----------------------------------------------------------------------------------
function uio() {
    project=$1
    filename=$(basename -- "$project")
    extension="${filename##*.}"
    filename="${filename%.*}"

    if [ "$project" = "" ]; then
        echo " ::Please enter the file name..."
    else
        if [[ ${extension} == "zip" ]]; then
            unzip -q $project
            echo " ::Checking the project structure ..."
            cd $filename
            if [ -e pom.xml ] || [ -e build.gradle ]; then
                echo " ::Opening the project" $filename
                cd ..
                idea $filename & 
                sleep 5
                echo " "
            else
                cd ..
                rm -rf $filename
                echo " ::The structure of the project is not maven nor gradle"
            fi
        else
            echo " :: Extension file doesn't support...."
        fi
    fi
}


#----------------------------------------------------------------------------------
# Set 'man' colors
#----------------------------------------------------------------------------------
function man() {
    env \
    LESS_TERMCAP_mb=$'\e[01;31m' \
    LESS_TERMCAP_md=$'\e[01;31m' \
    LESS_TERMCAP_me=$'\e[0m' \
    LESS_TERMCAP_se=$'\e[0m' \
    LESS_TERMCAP_so=$'\e[01;44;33m' \
    LESS_TERMCAP_ue=$'\e[0m' \
    LESS_TERMCAP_us=$'\e[01;32m' \
    man "$@"
}


#----------------------------------------------------------------------------------
# Finds files inside of the current path
#----------------------------------------------------------------------------------
function ff() {
    local rgfilter=" rg --files --follow --no-ignore-vcs --hidden -g '!{*/Library/*,.photoslibrary/*,node_modules/*,.git/*,**/build/*}' "
    selected=( \
        $(if [ "$1" = "-r" ]; then
            fzf -m \
                --prompt '📁 Search file: ' \
                --header $'Press <ENTER> to edit / <ESC> to exit.\n\n' \
                --border \
                --preview '[[ $(file --mime {}) =~ binary ]] &&
                echo {} is a binary file ||
                (bat --style=numbers --color=always {} ||
                    highlight -O ansi -l {} ||
                    coderay {} ||
                    rougify {} ||
                    cat {}) 2> /dev/null | head -500'
        else
            fzf -m \
                --prompt '📁 Search file: ' \
                --header $'Press <ENTER> to edit / <ESC> to exit.\n\n' \
                --border \
                --reverse --preview '[[ $(file --mime {}) =~ binary ]] &&
                echo {} is a binary file ||
                (bat --style=numbers --color=always {} ||
                    highlight -O ansi -l {} ||
                    coderay {} ||
                    rougify {} ||
                    cat {}) 2> /dev/null | head -500'
        fi))

    if [[ -z "$selected" ]]; then
        return 0
    fi

    nvim $selected
}


#----------------------------------------------------------------------------------
# Finds folders inside of the current path
#----------------------------------------------------------------------------------
function fd() {
    local cmd="${FZF_ALT_C_COMMAND:-"command find -L . -mindepth 1 \
    \\( -path '*/\\.*' -o -fstype 'sysfs' -o -fstype 'devfs' -o -fstype 'devtmpfs' \
    -o -fstype 'proc' -o -name 'node_modules' -o -name 'build' -o -name 'Library' \
    -o -name '*.photoslibrary' -o -name 'classes' \\) \
    -prune -o -type d -print 2> /dev/null | cut -b3-"}"

    local dir="$(eval "$cmd" | fzf -m \
        --height ${FZF_TMUX_HEIGHT:-40%} \
        --prompt '📁 Search folder: ' \
        --header $'Press <ESC> to exit.\n\n' \
        --border \
        --reverse)"

    if [[ -z "$dir" ]]; then
        return 0
    fi

    cd -- ${(q)dir}
}

#----------------------------------------------------------------------------------
# Clean duplicated entries
#----------------------------------------------------------------------------------
function czsh() {
    cd ~
    cat -n .zsh_history | sort -t ';' -uk2 | sort -nk1 | cut -f2- > .zsh_clean_history
    rm -rf .zsh_history .zcompdump* .zsh_sessions
    mv .zsh_clean_history .zsh_history
    cd -
}
